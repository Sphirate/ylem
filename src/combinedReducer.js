import { SymbolDispatch, SymbolGetActionTypes } from './symbols';
import { combineListeners, isReducer } from './helpers';

export const combineReducers = (map) => {
    if (!Object.values(map).every(isReducer)) {
        throw new Error('Every reducer must be generated by `createReducer` or `combineReducer` functions');
    }

    const handlersMap = Object.values(map).reduce((acc, reducer) => {
        reducer[SymbolGetActionTypes]().forEach((type) => {
            const handlersSet = [ ...(acc[type] || []), reducer[SymbolDispatch]];
            acc[type] = handlersSet;
        });
        return acc;
    }, {});

    Object.keys(handlersMap).forEach(actionType => {
        const combinedHandler = (...actions) => handlersMap[actionType]
            .reduce((acc, handler) => [ ...acc, ...handler(...actions)], []);

        handlers.set(actionType, combinedHandler);
    });

    const combineStates = () => Object.keys(map)
        .reduce((acc, key) => Object.assign({}, acc, {[key]: map[key].getState() }), {});

    const handlers = new Map();
    let state = combineStates();
    let listeners = [];

    const emit = (listenersChain = []) => {
        if (!listenersChain.length) {
            return listenersChain;
        }

        state = combineStates();

        if (!listeners.length) {
            return listenersChain;
        }

        return [ ...listenersChain, combineListeners(state, listeners)];
    };

    const dispatch = (...actions) => {
        const listenersChain = actions
            .filter(({ type }) => handlers.has(type))
            .reduce((acc, { type, payload }, _, filteredActions) => [
                ...acc,
                ...handlers.get(type)(...filteredActions),
            ], []);
        return emit(listenersChain);
    }

    const subscribe = (listener) => {
        if (typeof listener !== 'function') {
            throw new Error('Listener should be a function');
        }
        listeners.push(listener);
        return () => {
            listeners = listeners.filter(fn => fn !== listeners);
        };
    };

    return {
        subscribe,
        getState: () => state,
    };
}